SECTION 8
| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers    
 4: Vectors                    5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                      9: Functions               
10: lapply and sapply         11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 8

  |                                                                                    |   0%

| This lesson is meant to be a short introduction to logical operations in R.

...

  |==                                                                                  |   2%
| There are two logical values in R, also called boolean values. They are TRUE and FALSE. In
| R you can construct logical expressions which will evaluate to either TRUE or FALSE.

...

  |===                                                                                 |   4%
| Many of the questions in this lesson will involve evaluating logical expressions. It may be
| useful to open up a second R terminal where you can experiment with some of these
| expressions.

...

  |=====                                                                               |   6%
| Creating logical expressions requires logical operators. You're probably familiar with
| arithmetic operators like `+`, `-`, `*`, and `/`. The first logical operator we are going
| to discuss is the equality operator, represented by two equals signs `==`. Use the equality
| operator below to find out if TRUE is equal to TRUE.

> TRUE == TRUE
[1] TRUE

| You're the best!

  |======                                                                              |   8%
| Just like arithmetic, logical expressions can be grouped by parenthesis so that the entire
| expression (TRUE == TRUE) == TRUE evaluates to TRUE.

...

  |========                                                                            |  10%
| To test out this property, try evaluating (FALSE == TRUE) == FALSE .

> (FALSE == TRUE) == FALSE
[1] TRUE

| All that practice is paying off!

  |==========                                                                          |  12%
| The equality operator can also be used to compare numbers. Use `==` to see if 6 is equal to
| 7.

> 6 == 7
[1] FALSE

| Keep working like that and you'll get there!

  |===========                                                                         |  13%
| The previous expression evaluates to FALSE because 6 is less than 7. Thankfully, there are
| inequality operators that allow us to test if a value is less than or greater than another
| value.

...

  |=============                                                                       |  15%
| The less than operator `<` tests whether the number on the left side of the operator
| (called the left operand) is less than the number on the right side of the operator (called
| the right operand). Write an expression to test whether 6 is less than 7.

> 6 < 7
[1] TRUE

| You're the best!

  |===============                                                                     |  17%
| There is also a less-than-or-equal-to operator `<=` which tests whether the left operand is
| less than or equal to the right operand. Write an expression to test whether 10 is less
| than or equal to 10.

> 10 <= 10
[1] TRUE

| Keep working like that and you'll get there!

  |================                                                                    |  19%
| Keep in mind that there are the corresponding greater than `>` and greater-than-or-equal-to
| `>=` operators.

...

  |==================                                                                  |  21%
| Which of the following evaluates to FALSE?

1: 9 >= 10
2: 6 < 8
3: 0 > -36
4: 7 == 7

Selection: 1

| That's the answer I was looking for.

  |===================                                                                 |  23%
| Which of the following evaluates to TRUE?

1: 7 == 9
2: -6 > -7
3: 57 < 8
4: 9 >= 10

Selection: 2

| You got it right!

  |=====================                                                               |  25%
| The next operator we will discuss is the 'not equals' operator represented by `!=`. Not
| equals tests whether two values are unequal, so TRUE != FALSE evaluates to TRUE. Like the
| equality operator, `!=` can also be used with numbers. Try writing an expression to see if
| 5 is not equal to 7.

> 5 != 7
[1] TRUE

| Excellent job!

  |=======================                                                             |  27%
| In order to negate boolean expressions you can use the NOT operator. An exclamation point
| `!` will cause !TRUE (say: not true) to evaluate to FALSE and !FALSE (say: not false) to
| evaluate to TRUE. Try using the NOT operator and the equals operator to find the opposite
| of whether 5 is equal to 7.

> !(5 == 7)
[1] TRUE

| Excellent job!

  |========================                                                            |  29%
| Let's take a moment to review. The equals operator `==` tests whether two boolean values or
| numbers are equal, the not equals operator `!=` tests whether two boolean values or numbers
| are unequal, and the NOT operator `!` negates logical expressions so that TRUE expressions
| become FALSE and FALSE expressions become TRUE.

...

  |==========================                                                          |  31%
| Which of the following evaluates to FALSE?

1: !FALSE
2: !(0 >= -1)
3: 9 < 10
4: 7 != 8

Selection: 2

| You got it!

  |===========================                                                         |  33%
| What do you think the following expression will evaluate to?: (TRUE != FALSE) == !(6 == 7)

1: FALSE
2: %>%
3: TRUE
4: Can there be objective truth when programming?

Selection: 3

| You got it!

  |=============================                                                       |  35%
| At some point you may need to examine relationships between multiple logical expressions.
| This is where the AND operator and the OR operator come in.

...

  |===============================                                                     |  37%
| Let's look at how the AND operator works. There are two AND operators in R, `&` and `&&`.
| Both operators work similarly, if the right and left operands of AND are both TRUE the
| entire expression is TRUE, otherwise it is FALSE. For example, TRUE & TRUE evaluates to
| TRUE. Try typing FALSE & FALSE to how it is evaluated.

> FALSE & FALSE
[1] FALSE

| All that hard work is paying off!

  |================================                                                    |  38%
| You can use the `&` operator to evaluate AND across a vector. The `&&` version of AND only
| evaluates the first member of a vector. Let's test both for practice. Type the expression
| TRUE & c(TRUE, FALSE, FALSE).

> TRUE & C(TRUE, FALSE, FALSE)
Error in C(TRUE, FALSE, FALSE) : object not interpretable as a factor
> TRUE & c(TRUE, FALSE, FALSE)
[1]  TRUE FALSE FALSE

| You're the best!

  |==================================                                                  |  40%
| What happens in this case is that the left operand `TRUE` is recycled across every element
| in the vector of the right operand. This is the equivalent statement as c(TRUE, TRUE, TRUE)
| & c(TRUE, FALSE, FALSE).

...

  |====================================                                                |  42%
| Now we'll type the same expression except we'll use the `&&` operator. Type the expression
| TRUE && c(TRUE, FALSE, FALSE).

> TRUE && c(TRUE, FALSE, FALSE)
[1] TRUE

| You're the best!

  |=====================================                                               |  44%
| In this case, the left operand is only evaluated with the first member of the right operand
| (the vector). The rest of the elements in the vector aren't evaluated at all in this
| expression.

...

  |=======================================                                             |  46%
| The OR operator follows a similar set of rules. The `|` version of OR evaluates OR across
| an entire vector, while the `||` version of OR only evaluates the first member of a vector.

...

  |========================================                                            |  48%
| An expression using the OR operator will evaluate to TRUE if the left operand or the right
| operand is TRUE. If both are TRUE, the expression will evaluate to TRUE, however if neither
| are TRUE, then the expression will be FALSE.

...

  |==========================================                                          |  50%
| Let's test out the vectorized version of the OR operator. Type the expression TRUE |
| c(TRUE, FALSE, FALSE).

> TRUE | c(TRUE, FALSE, FALSE)
[1] TRUE TRUE TRUE

| Keep up the great work!

  |============================================                                        |  52%
| Now let's try out the non-vectorized version of the OR operator. Type the expression TRUE
| || c(TRUE, FALSE, FALSE).

> TRUE || c(TRUE, FALSE, FALSE)
[1] TRUE

| You got it right!

  |=============================================                                       |  54%
| Logical operators can be chained together just like arithmetic operators. The expressions:
| `6 != 10 && FALSE && 1 >= 2` or `TRUE || 5 < 9.3 || FALSE` are perfectly normal to see.

...

  |===============================================                                     |  56%
| As you may recall, arithmetic has an order of operations and so do logical expressions. All
| AND operators are evaluated before OR operators. Let's look at an example of an ambiguous
| case. Type: 5 > 8 || 6 != 8 && 4 > 3.9

> 5 > 8 || 6 != 8 && 4 > 3.9
[1] TRUE

| Perseverance, that's the answer.

  |================================================                                    |  58%
| Let's walk through the order of operations in the above case. First the left and right
| operands of the AND operator are evaluated. 6 is not equal 8, 4 is greater than 3.9,
| therefore both operands are TRUE so the resulting expression `TRUE && TRUE` evaluates to
| TRUE. Then the left operand of the OR operator is evaluated: 5 is not greater than 8 so the
| entire expression is reduced to FALSE || TRUE. Since the right operand of this expression
| is TRUE the entire expression evaluates to TRUE.

...

  |==================================================                                  |  60%
| Which one of the following expressions evaluates to TRUE?

1: 99.99 > 100 || 45 < 7.3 || 4 != 4.0
2: TRUE && FALSE || 9 >= 4 && 3 < 6
3: TRUE && 62 < 62 && 44 >= 44
4: FALSE || TRUE && FALSE

Selection: 2

| That's a job well done!

  |====================================================                                |  62%
| Which one of the following expressions evaluates to FALSE?

1: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5
2: 6 >= -9 && !(6 > 7) && !(!TRUE)
3: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79
4: FALSE || TRUE && 6 != 4 || 9 > 4

Selection: 2

| Not exactly. Give it another go.

| Try to evaluate each expression in isolation and build up an answer.

1: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5
2: FALSE || TRUE && 6 != 4 || 9 > 4
3: 6 >= -9 && !(6 > 7) && !(!TRUE)
4: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79

Selection: 1

| You got it!

  |=====================================================                               |  63%
| Now that you're familiar with R's logical operators you can take advantage of a few
| functions that R provides for dealing with logical expressions.

...

  |=======================================================                             |  65%
| The function isTRUE() takes one argument. If that argument evaluates to TRUE, the function
| will return TRUE. Otherwise, the function will return FALSE. Try using this function by
| typing: isTRUE(6 > 4)

> isTRUE(6 > 4)
[1] TRUE

| That's a job well done!

  |=========================================================                           |  67%
| Which of the following evaluates to TRUE?

1: isTRUE(!TRUE)
2: isTRUE(NA)
3: isTRUE(3)
4: !isTRUE(8 != 5)
5: !isTRUE(4 < 3)

Selection: 3

| Try again. Getting it right on the first try is boring anyway!

| isTRUE() will only return TRUE if the statement passed to it as an argument is TRUE.

1: !isTRUE(4 < 3)
2: isTRUE(NA)
3: !isTRUE(8 != 5)
4: isTRUE(!TRUE)
5: isTRUE(3)

Selection: 1

| Great job!

  |==========================================================                          |  69%
| The function identical() will return TRUE if the two R objects passed to it as arguments
| are identical. Try out the identical() function by typing: identical('twins', 'twins')

> identical('twins','twins')
[1] TRUE

| You got it right!

  |============================================================                        |  71%
| Which of the following evaluates to TRUE?

1: identical(5 > 4, 3 < 3.1)
2: !identical(7, 7)
3: identical(4, 3.1)
4: identical('hello', 'Hello')

Selection: 1

| Keep up the great work!

  |=============================================================                       |  73%
| You should also be aware of the xor() function, which takes two arguments. The xor()
| function stands for exclusive OR. If one argument evaluates to TRUE and one argument
| evaluates to FALSE, then this function will return TRUE, otherwise it will return FALSE.
| Try out the xor() function by typing: xor(5 == 6, !FALSE)

> xor(5==6, !FALSE)
[1] TRUE

| You're the best!

  |===============================================================                     |  75%
| 5 == 6 evaluates to FALSE, !FALSE evaluates to TRUE, so xor(FALSE, TRUE) evaluates to TRUE.
| On the other hand if the first argument was changed to 5 == 5 and the second argument was
| unchanged then both arguments would have been TRUE, so xor(TRUE, TRUE) would have evaluated
| to FALSE.

...

  |=================================================================                   |  77%
| Which of the following evaluates to FALSE?

1: xor(identical(xor, 'xor'), 7 == 7.0)
2: xor(!!TRUE, !!FALSE)
3: xor(4 >= 9, 8 != 8.0)
4: xor(!isTRUE(TRUE), 6 > -1)

Selection: 2

| Not quite right, but keep trying.

| For xor() to evaluate to TRUE, one argument must be TRUE and one must be FALSE.

1: xor(identical(xor, 'xor'), 7 == 7.0)
2: xor(!isTRUE(TRUE), 6 > -1)
3: xor(!!TRUE, !!FALSE)
4: xor(4 >= 9, 8 != 8.0)

Selection: 4

| You got it right!

  |==================================================================                  |  79%
| For the next few questions, we're going to need to create a vector of integers called ints.
| Create this vector by typing: ints <- sample(10)

> ints <- sample(10)

| Excellent job!

  |====================================================================                |  81%
| Now simply display the contents of ints.

> ints
 [1]  3  8  9  2  6  5  1  7 10  4

| Excellent work!

  |=====================================================================               |  83%
| The vector `ints` is a random sampling of integers from 1 to 10 without replacement. Let's
| say we wanted to ask some logical questions about contents of ints. If we type ints > 5, we
| will get a logical vector corresponding to whether each element of ints is greater than 5.
| Try typing: ints > 5

> ints > 5
 [1] FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE

| You are really on a roll!

  |=======================================================================             |  85%
| We can use the resulting logical vector to ask other questions about ints. The which()
| function takes a logical vector as an argument and returns the indices of the vector that
| are TRUE. For example which(c(TRUE, FALSE, TRUE)) would return the vector c(1, 3).

...which(c(TRUE, FALSE, TRUE))

  |=========================================================================           |  87%
| Use the which() function to find the indices of ints that are greater than 7.

> which(c(TRUE, FALSE, TRUE))
[1] 1 3

| You're close...I can feel it! Try it again. Or, type info() for more options.

| Use the which() function on the logical vector produced by: `ints > 7`

> which (ints > 7)
[1] 2 3 9

| Keep working like that and you'll get there!

  |==========================================================================          |  88%
| Which of the following commands would produce the indices of the elements in ints that are
| less than or equal to 2?

1: which(ints < 2)
2: ints < 2
3: ints <= 2
4: which(ints <= 2)

Selection: 4

| You're the best!

  |============================================================================        |  90%
| Like the which() function, the functions any() and all() take logical vectors as their
| argument. The any() function will return TRUE if one or more of the elements in the logical
| vector is TRUE. The all() function will return TRUE if every element in the logical vector
| is TRUE.

... 

  |==============================================================================      |  92%
| Use the any() function to see if any of the elements of ints are less than zero.

> any(ints < 0)
[1] FALSE

| You're the best!

  |===============================================================================     |  94%
| Use the all() function to see if all of the elements of ints are greater than zero.

> all(ints < 0)
[1] FALSE

| Try again. Getting it right on the first try is boring anyway! Or, type info() for more
| options.

| Use the all() function on the logical vector produced by: `ints > 0`

> all(ints > 0)
[1] TRUE

| You are doing so well!

  |=================================================================================   |  96%
| Which of the following evaluates to TRUE?

1: any(ints == 2.5)
2: all(c(TRUE, FALSE, TRUE))
3: all(ints == 10)
4: any(ints == 10)

Selection: 4

| Excellent work!

  |==================================================================================  |  98%
| That's all for this introduction to logic in R. If you really want to see what you can do
| with logic, check out the control flow lesson!

...

  |====================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

SECTION 9

  |==                                                                                  |   2%
| There are two logical values in R, also called boolean values. They are TRUE and FALSE. In
| R you can construct logical expressions which will evaluate to either TRUE or FALSE.

...

  |===                                                                                 |   4%
| Many of the questions in this lesson will involve evaluating logical expressions. It may be
| useful to open up a second R terminal where you can experiment with some of these
| expressions.

...

  |=====                                                                               |   6%
| Creating logical expressions requires logical operators. You're probably familiar with
| arithmetic operators like `+`, `-`, `*`, and `/`. The first logical operator we are going
| to discuss is the equality operator, represented by two equals signs `==`. Use the equality
| operator below to find out if TRUE is equal to TRUE.

> TRUE == TRUE
[1] TRUE

| You're the best!

  |======                                                                              |   8%
| Just like arithmetic, logical expressions can be grouped by parenthesis so that the entire
| expression (TRUE == TRUE) == TRUE evaluates to TRUE.

...

  |========                                                                            |  10%
| To test out this property, try evaluating (FALSE == TRUE) == FALSE .

> (FALSE == TRUE) == FALSE
[1] TRUE

| All that practice is paying off!

  |==========                                                                          |  12%
| The equality operator can also be used to compare numbers. Use `==` to see if 6 is equal to
| 7.

> 6 == 7
[1] FALSE

| Keep working like that and you'll get there!

  |===========                                                                         |  13%
| The previous expression evaluates to FALSE because 6 is less than 7. Thankfully, there are
| inequality operators that allow us to test if a value is less than or greater than another
| value.

...

  |=============                                                                       |  15%
| The less than operator `<` tests whether the number on the left side of the operator
| (called the left operand) is less than the number on the right side of the operator (called
| the right operand). Write an expression to test whether 6 is less than 7.

> 6 < 7
[1] TRUE

| You're the best!

  |===============                                                                     |  17%
| There is also a less-than-or-equal-to operator `<=` which tests whether the left operand is
| less than or equal to the right operand. Write an expression to test whether 10 is less
| than or equal to 10.

> 10 <= 10
[1] TRUE

| Keep working like that and you'll get there!

  |================                                                                    |  19%
| Keep in mind that there are the corresponding greater than `>` and greater-than-or-equal-to
| `>=` operators.

...

  |==================                                                                  |  21%
| Which of the following evaluates to FALSE?

1: 9 >= 10
2: 6 < 8
3: 0 > -36
4: 7 == 7

Selection: 1

| That's the answer I was looking for.

  |===================                                                                 |  23%
| Which of the following evaluates to TRUE?

1: 7 == 9
2: -6 > -7
3: 57 < 8
4: 9 >= 10

Selection: 2

| You got it right!

  |=====================                                                               |  25%
| The next operator we will discuss is the 'not equals' operator represented by `!=`. Not
| equals tests whether two values are unequal, so TRUE != FALSE evaluates to TRUE. Like the
| equality operator, `!=` can also be used with numbers. Try writing an expression to see if
| 5 is not equal to 7.

> 5 != 7
[1] TRUE

| Excellent job!

  |=======================                                                             |  27%
| In order to negate boolean expressions you can use the NOT operator. An exclamation point
| `!` will cause !TRUE (say: not true) to evaluate to FALSE and !FALSE (say: not false) to
| evaluate to TRUE. Try using the NOT operator and the equals operator to find the opposite
| of whether 5 is equal to 7.

> !(5 == 7)
[1] TRUE

| Excellent job!

  |========================                                                            |  29%
| Let's take a moment to review. The equals operator `==` tests whether two boolean values or
| numbers are equal, the not equals operator `!=` tests whether two boolean values or numbers
| are unequal, and the NOT operator `!` negates logical expressions so that TRUE expressions
| become FALSE and FALSE expressions become TRUE.

...

  |==========================                                                          |  31%
| Which of the following evaluates to FALSE?

1: !FALSE
2: !(0 >= -1)
3: 9 < 10
4: 7 != 8

Selection: 2

| You got it!

  |===========================                                                         |  33%
| What do you think the following expression will evaluate to?: (TRUE != FALSE) == !(6 == 7)

1: FALSE
2: %>%
3: TRUE
4: Can there be objective truth when programming?

Selection: 3

| You got it!

  |=============================                                                       |  35%
| At some point you may need to examine relationships between multiple logical expressions.
| This is where the AND operator and the OR operator come in.

...

  |===============================                                                     |  37%
| Let's look at how the AND operator works. There are two AND operators in R, `&` and `&&`.
| Both operators work similarly, if the right and left operands of AND are both TRUE the
| entire expression is TRUE, otherwise it is FALSE. For example, TRUE & TRUE evaluates to
| TRUE. Try typing FALSE & FALSE to how it is evaluated.

> FALSE & FALSE
[1] FALSE

| All that hard work is paying off!

  |================================                                                    |  38%
| You can use the `&` operator to evaluate AND across a vector. The `&&` version of AND only
| evaluates the first member of a vector. Let's test both for practice. Type the expression
| TRUE & c(TRUE, FALSE, FALSE).

> TRUE & C(TRUE, FALSE, FALSE)
Error in C(TRUE, FALSE, FALSE) : object not interpretable as a factor
> TRUE & c(TRUE, FALSE, FALSE)
[1]  TRUE FALSE FALSE

| You're the best!

  |==================================                                                  |  40%
| What happens in this case is that the left operand `TRUE` is recycled across every element
| in the vector of the right operand. This is the equivalent statement as c(TRUE, TRUE, TRUE)
| & c(TRUE, FALSE, FALSE).

...

  |====================================                                                |  42%
| Now we'll type the same expression except we'll use the `&&` operator. Type the expression
| TRUE && c(TRUE, FALSE, FALSE).

> TRUE && c(TRUE, FALSE, FALSE)
[1] TRUE

| You're the best!

  |=====================================                                               |  44%
| In this case, the left operand is only evaluated with the first member of the right operand
| (the vector). The rest of the elements in the vector aren't evaluated at all in this
| expression.

...

  |=======================================                                             |  46%
| The OR operator follows a similar set of rules. The `|` version of OR evaluates OR across
| an entire vector, while the `||` version of OR only evaluates the first member of a vector.

...

  |========================================                                            |  48%
| An expression using the OR operator will evaluate to TRUE if the left operand or the right
| operand is TRUE. If both are TRUE, the expression will evaluate to TRUE, however if neither
| are TRUE, then the expression will be FALSE.

...

  |==========================================                                          |  50%
| Let's test out the vectorized version of the OR operator. Type the expression TRUE |
| c(TRUE, FALSE, FALSE).

> TRUE | c(TRUE, FALSE, FALSE)
[1] TRUE TRUE TRUE

| Keep up the great work!

  |============================================                                        |  52%
| Now let's try out the non-vectorized version of the OR operator. Type the expression TRUE
| || c(TRUE, FALSE, FALSE).

> TRUE || c(TRUE, FALSE, FALSE)
[1] TRUE

| You got it right!

  |=============================================                                       |  54%
| Logical operators can be chained together just like arithmetic operators. The expressions:
| `6 != 10 && FALSE && 1 >= 2` or `TRUE || 5 < 9.3 || FALSE` are perfectly normal to see.

...

  |===============================================                                     |  56%
| As you may recall, arithmetic has an order of operations and so do logical expressions. All
| AND operators are evaluated before OR operators. Let's look at an example of an ambiguous
| case. Type: 5 > 8 || 6 != 8 && 4 > 3.9

> 5 > 8 || 6 != 8 && 4 > 3.9
[1] TRUE

| Perseverance, that's the answer.

  |================================================                                    |  58%
| Let's walk through the order of operations in the above case. First the left and right
| operands of the AND operator are evaluated. 6 is not equal 8, 4 is greater than 3.9,
| therefore both operands are TRUE so the resulting expression `TRUE && TRUE` evaluates to
| TRUE. Then the left operand of the OR operator is evaluated: 5 is not greater than 8 so the
| entire expression is reduced to FALSE || TRUE. Since the right operand of this expression
| is TRUE the entire expression evaluates to TRUE.

...

  |==================================================                                  |  60%
| Which one of the following expressions evaluates to TRUE?

1: 99.99 > 100 || 45 < 7.3 || 4 != 4.0
2: TRUE && FALSE || 9 >= 4 && 3 < 6
3: TRUE && 62 < 62 && 44 >= 44
4: FALSE || TRUE && FALSE

Selection: 2

| That's a job well done!

  |====================================================                                |  62%
| Which one of the following expressions evaluates to FALSE?

1: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5
2: 6 >= -9 && !(6 > 7) && !(!TRUE)
3: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79
4: FALSE || TRUE && 6 != 4 || 9 > 4

Selection: 2

| Not exactly. Give it another go.

| Try to evaluate each expression in isolation and build up an answer.

1: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5
2: FALSE || TRUE && 6 != 4 || 9 > 4
3: 6 >= -9 && !(6 > 7) && !(!TRUE)
4: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79

Selection: 1

| You got it!

  |=====================================================                               |  63%
| Now that you're familiar with R's logical operators you can take advantage of a few
| functions that R provides for dealing with logical expressions.

...

  |=======================================================                             |  65%
| The function isTRUE() takes one argument. If that argument evaluates to TRUE, the function
| will return TRUE. Otherwise, the function will return FALSE. Try using this function by
| typing: isTRUE(6 > 4)

> isTRUE(6 > 4)
[1] TRUE

| That's a job well done!

  |=========================================================                           |  67%
| Which of the following evaluates to TRUE?

1: isTRUE(!TRUE)
2: isTRUE(NA)
3: isTRUE(3)
4: !isTRUE(8 != 5)
5: !isTRUE(4 < 3)

Selection: 3

| Try again. Getting it right on the first try is boring anyway!

| isTRUE() will only return TRUE if the statement passed to it as an argument is TRUE.

1: !isTRUE(4 < 3)
2: isTRUE(NA)
3: !isTRUE(8 != 5)
4: isTRUE(!TRUE)
5: isTRUE(3)

Selection: 1

| Great job!

  |==========================================================                          |  69%
| The function identical() will return TRUE if the two R objects passed to it as arguments
| are identical. Try out the identical() function by typing: identical('twins', 'twins')

> identical('twins','twins')
[1] TRUE

| You got it right!

  |============================================================                        |  71%
| Which of the following evaluates to TRUE?

1: identical(5 > 4, 3 < 3.1)
2: !identical(7, 7)
3: identical(4, 3.1)
4: identical('hello', 'Hello')

Selection: 1

| Keep up the great work!

  |=============================================================                       |  73%
| You should also be aware of the xor() function, which takes two arguments. The xor()
| function stands for exclusive OR. If one argument evaluates to TRUE and one argument
| evaluates to FALSE, then this function will return TRUE, otherwise it will return FALSE.
| Try out the xor() function by typing: xor(5 == 6, !FALSE)

> xor(5==6, !FALSE)
[1] TRUE

| You're the best!

  |===============================================================                     |  75%
| 5 == 6 evaluates to FALSE, !FALSE evaluates to TRUE, so xor(FALSE, TRUE) evaluates to TRUE.
| On the other hand if the first argument was changed to 5 == 5 and the second argument was
| unchanged then both arguments would have been TRUE, so xor(TRUE, TRUE) would have evaluated
| to FALSE.

...

  |=================================================================                   |  77%
| Which of the following evaluates to FALSE?

1: xor(identical(xor, 'xor'), 7 == 7.0)
2: xor(!!TRUE, !!FALSE)
3: xor(4 >= 9, 8 != 8.0)
4: xor(!isTRUE(TRUE), 6 > -1)

Selection: 2

| Not quite right, but keep trying.

| For xor() to evaluate to TRUE, one argument must be TRUE and one must be FALSE.

1: xor(identical(xor, 'xor'), 7 == 7.0)
2: xor(!isTRUE(TRUE), 6 > -1)
3: xor(!!TRUE, !!FALSE)
4: xor(4 >= 9, 8 != 8.0)

Selection: 4

| You got it right!

  |==================================================================                  |  79%
| For the next few questions, we're going to need to create a vector of integers called ints.
| Create this vector by typing: ints <- sample(10)

> ints <- sample(10)

| Excellent job!

  |====================================================================                |  81%
| Now simply display the contents of ints.

> ints
 [1]  3  8  9  2  6  5  1  7 10  4

| Excellent work!

  |=====================================================================               |  83%
| The vector `ints` is a random sampling of integers from 1 to 10 without replacement. Let's
| say we wanted to ask some logical questions about contents of ints. If we type ints > 5, we
| will get a logical vector corresponding to whether each element of ints is greater than 5.
| Try typing: ints > 5

> ints > 5
 [1] FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE

| You are really on a roll!

  |=======================================================================             |  85%
| We can use the resulting logical vector to ask other questions about ints. The which()
| function takes a logical vector as an argument and returns the indices of the vector that
| are TRUE. For example which(c(TRUE, FALSE, TRUE)) would return the vector c(1, 3).

...which(c(TRUE, FALSE, TRUE))

  |=========================================================================           |  87%
| Use the which() function to find the indices of ints that are greater than 7.

> which(c(TRUE, FALSE, TRUE))
[1] 1 3

| You're close...I can feel it! Try it again. Or, type info() for more options.

| Use the which() function on the logical vector produced by: `ints > 7`

> which (ints > 7)
[1] 2 3 9

| Keep working like that and you'll get there!

  |==========================================================================          |  88%
| Which of the following commands would produce the indices of the elements in ints that are
| less than or equal to 2?

1: which(ints < 2)
2: ints < 2
3: ints <= 2
4: which(ints <= 2)

Selection: 4

| You're the best!

  |============================================================================        |  90%
| Like the which() function, the functions any() and all() take logical vectors as their
| argument. The any() function will return TRUE if one or more of the elements in the logical
| vector is TRUE. The all() function will return TRUE if every element in the logical vector
| is TRUE.

... 

  |==============================================================================      |  92%
| Use the any() function to see if any of the elements of ints are less than zero.

> any(ints < 0)
[1] FALSE

| You're the best!

  |===============================================================================     |  94%
| Use the all() function to see if all of the elements of ints are greater than zero.

> all(ints < 0)
[1] FALSE

| Try again. Getting it right on the first try is boring anyway! Or, type info() for more
| options.

| Use the all() function on the logical vector produced by: `ints > 0`

> all(ints > 0)
[1] TRUE

| You are doing so well!

  |=================================================================================   |  96%
| Which of the following evaluates to TRUE?

1: any(ints == 2.5)
2: all(c(TRUE, FALSE, TRUE))
3: all(ints == 10)
4: any(ints == 10)

Selection: 4

| Excellent work!

  |==================================================================================  |  98%
| That's all for this introduction to logic in R. If you really want to see what you can do
| with logic, check out the control flow lesson!

...

  |====================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

Selection: 2

| Keep working like that and you'll get there!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers    
 4: Vectors                    5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                      9: Functions               
10: lapply and sapply         11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 9

  |                                                                                    |   0%

| Functions are one of the fundamental building blocks of the R language. They are small
| pieces of reusable code that can be treated like any other R object.

...

  |==                                                                                  |   2%
| If you've worked through any other part of this course, you've probably used some functions
| already. Functions are usually characterized by the name of the function followed by
| parentheses.

...

  |===                                                                                 |   4%
| Let's try using a few basic functions just for fun. The Sys.Date() function returns a
| string representing today's date. Type Sys.Date() below and see what happens.

> Sys.Date()
[1] "2018-09-06"

| Your dedication is inspiring!

  |=====                                                                               |   6%
| Most functions in R return a value. Functions like Sys.Date() return a value based on your
| computer's environment, while other functions manipulate input data in order to compute a
| return value.

...

  |=======                                                                             |   8%
| The mean() function takes a vector of numbers as input, and returns the average of all of
| the numbers in the input vector. Inputs to functions are often called arguments. Providing
| arguments to a function is also sometimes called passing arguments to that function.
| Arguments you want to pass to a function go inside the function's parentheses. Try passing
| the argument c(2, 4, 5) to the mean() function.

> mean(c(2,4,5))
[1] 3.666667

| That's the answer I was looking for.

  |=========                                                                           |  10%
| Functions usually take arguments which are variables that the function operates on. For
| example, the mean() function takes a vector as an argument, like in the case of
| mean(c(2,6,8)). The mean() function then adds up all of the numbers in the vector and
| divides that sum by the length of the vector.

...

  |==========                                                                          |  12%
| In the following question you will be asked to modify a script that will appear as soon as
| you move on from this question. When you have finished modifying the script, save your
| changes to the script and type submit() and the script will be evaluated. There will be
| some comments in the script that opens up, so be sure to read them!

...

  |============                                                                        |  14%
| The last R expression to be evaluated in a function will become the return value of that
| function. We want this function to take one argument, x, and return x without modifying it.
| Delete the pound sign so that x is returned without any modification. Make sure to save
| your script before you type submit().

> submit()

| Sourcing your script...


| You're the best!

  |==============                                                                      |  16%
| Now that you've created your first function let's test it! Type: boring_function('My first
| function!'). If your function works, it should just return the string: 'My first function!'

> boring_function('My first function!')
[1] "My first function!"

| You got it!

  |===============                                                                     |  18%
| Congratulations on writing your first function. By writing functions, you can gain serious
| insight into how R works. As John Chambers, the creator of R once said:
| 
| To understand computations in R, two slogans are helpful: 1. Everything that exists is an
| object. 2. Everything that happens is a function call.

...

  |=================                                                                   |  20%
| If you want to see the source code for any function, just type the function name without
| any arguments or parentheses. Let's try this out with the function you just created. Type:
| boring_function to view its source code.

> boring_function
function(x) {
  x
}
<bytecode: 0x107598d38>

| All that hard work is paying off!

  |===================                                                                 |  22%
| Time to make a more useful function! We're going to replicate the functionality of the
| mean() function by creating a function called: my_mean(). Remember that to calculate the
| average of all of the numbers in a vector you find the sum of all the numbers in the
| vector, and then divide that sum by the number of numbers in the vector.

...

  |=====================                                                               |  24%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| That's a job well done!

  |======================                                                              |  27%
| Now test out your my_mean() function by finding the mean of the vector c(4, 5, 10).

> my_mean(c(4,5,10))
[1] 6.333333

| That's a job well done!

  |========================                                                            |  29%
| Next, let's try writing a function with default arguments. You can set default values for a
| function's arguments, and this can be useful if you think someone who uses your function
| will set a certain argument to the same value most of the time.

...

  |==========================                                                          |  31%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Your dedication is inspiring!

  |===========================                                                         |  33%
| Let's do some testing of the remainder function. Run remainder(5) and see what happens.

> remainder(5)
[1] 1

| All that hard work is paying off!

  |=============================                                                       |  35%
| Let's take a moment to examine what just happened. You provided one argument to the
| function, and R matched that argument to 'num' since 'num' is the first argument. The
| default value for 'divisor' is 2, so the function used the default value you provided.

...

  |===============================                                                     |  37%
| Now let's test the remainder function by providing two arguments. Type: remainder(11, 5)
| and let's see what happens.

> remainder(11,5)
[1] 1

| Your dedication is inspiring!

  |=================================                                                   |  39%
| Once again, the arguments have been matched appropriately.

...

  |==================================                                                  |  41%
| You can also explicitly specify arguments in a function. When you explicitly designate
| argument values by name, the ordering of the arguments becomes unimportant. You can try
| this out by typing: remainder(divisor = 11, num = 5).

> remainder(divisor = 11, num = 5)
[1] 5

| That's a job well done!

  |====================================                                                |  43%
| As you can see, there is a significant difference between remainder(11, 5) and
| remainder(divisor = 11, num = 5)!

...

  |======================================                                              |  45%
| R can also partially match arguments. Try typing remainder(4, div = 2) to see this feature
| in action.

> remainder(4, div = 2)
[1] 0

| Great job!

  |=======================================                                             |  47%
| A word of warning: in general you want to make your code as easy to understand as possible.
| Switching around the orders of arguments by specifying their names or only using partial
| argument names can be confusing, so use these features with caution!

...

  |=========================================                                           |  49%
| With all of this talk about arguments, you may be wondering if there is a way you can see a
| function's arguments (besides looking at the documentation). Thankfully, you can use the
| args() function! Type: args(remainder) to examine the arguments for the remainder function.

> args(remainder)
function (num, divisor = 2) 
NULL

| Excellent job!

  |===========================================                                         |  51%
| You may not realize it but I just tricked you into doing something pretty interesting!
| args() is a function, remainder() is a function, yet remainder was an argument for args().
| Yes it's true: you can pass functions as arguments! This is a very powerful concept. Let's
| write a script to see how it works.

...

  |=============================================                                       |  53%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Keep working like that and you'll get there!

  |==============================================                                      |  55%
| Let's take your new evaluate() function for a spin! Use evaluate to find the standard
| deviation of the vector c(1.4, 3.6, 7.9, 8.8).

> evaluate(sd, c(1.4,3.6,7.9,8.8))
[1] 3.514138

| Excellent job!

  |================================================                                    |  57%
| The idea of passing functions as arguments to other functions is an important and
| fundamental concept in programming.

...

  |==================================================                                  |  59%
| You may be surprised to learn that you can pass a function as an argument without first
| defining the passed function. Functions that are not named are appropriately known as
| anonymous functions.

...

  |===================================================                                 |  61%
| Let's use the evaluate function to explore how anonymous functions work. For the first
| argument of the evaluate function we're going to write a tiny function that fits on one
| line. In the second argument we'll pass some data to the tiny anonymous function in the
| first argument.

...

  |=====================================================                               |  63%
| Type the following command and then we'll discuss how it works: evaluate(function(x){x+1},
| 6)

> evaluate(function(x){x+1}, 6)
[1] 7

| You're the best!

  |=======================================================                             |  65%
| The first argument is a tiny anonymous function that takes one argument `x` and returns
| `x+1`. We passed the number 6 into this function so the entire expression evaluates to 7.

...

  |=========================================================                           |  67%
| Try using evaluate() along with an anonymous function to return the first element of the
| vector c(8, 4, 0). Your anonymous function should only take one argument which should be a
| variable `x`.

> 
> evaluate(function(x){x[1]}, c(8,4,0))
[1] 8

| All that hard work is paying off!

  |==========================================================                          |  69%
| Now try using evaluate() along with an anonymous function to return the last element of the
| vector c(8, 4, 0). Your anonymous function should only take one argument which should be a
| variable `x`.

> evaluate(function(x){x[1]}, c(8,4,0)[3])
[1] 0

| Not quite right, but keep trying. Or, type info() for more options.

| You may need to recall how to index vector elements. Remember that your anonymous function
| should only have one argument, and that argument should be named `x`. Using the length()
| function in your anonymous function may help you.

> evaluate(function(x){x[1]}, c(8,4,0)[-1])
[1] 4

| That's not exactly what I'm looking for. Try again. Or, type info() for more options.

| You may need to recall how to index vector elements. Remember that your anonymous function
| should only have one argument, and that argument should be named `x`. Using the length()
| function in your anonymous function may help you.

> evaluate(function(x){x[1]}, c(8,4,0)[0])
[1] NA

| Not exactly. Give it another go. Or, type info() for more options.

| You may need to recall how to index vector elements. Remember that your anonymous function
| should only have one argument, and that argument should be named `x`. Using the length()
| function in your anonymous function may help you.

> evaluate(function(x){x[1]}, c(8,4,0)[x.length())
Error: unexpected ')' in "evaluate(function(x){x[1]}, c(8,4,0)[x.length())"
> evaluate(function(x){x[1]}, c(8,4,0)[x.length()])
Error in x.length() : could not find function "x.length"
> evaluate(function(x){x[1]}, c(8,4,0)[length(x)])
Error in func(dat) : object 'x' not found
> evaluate(function(x){x.length()]}, c(8,4,0))
Error: unexpected ']' in "evaluate(function(x){x.length()]"
> evaluate(function(x){x[-1]}, c(8,4,0))
[1] 4 0

| That's a job well done!

  |============================================================                        |  71%
| For the rest of the course we're going to use the paste() function frequently. Type ?paste
| so we can take a look at the documentation for the paste function.

> ?paste

| You are doing so well!

  |==============================================================                      |  73%
| As you can see the first argument of paste() is `...` which is referred to as an ellipsis
| or simply dot-dot-dot. The ellipsis allows an indefinite number of arguments to be passed
| into a function. In the case of paste() any number of strings can be passed as arguments
| and paste() will return all of the strings combined into one string.

...

  |===============================================================                     |  76%
| Just to see how paste() works, type paste("Programming", "is", "fun!")

> paste("Programming", "is", "fun!")
[1] "Programming is fun!"

| You got it!

  |=================================================================                   |  78%
| Time to write our own modified version of paste().

...

  |===================================================================                 |  80%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| You nailed it! Good job!

  |=====================================================================               |  82%
| Now let's test out your telegram function. Use your new telegram function passing in
| whatever arguments you wish!

> telegram(c("yo", "lo"))
[1] "START yo STOP" "START lo STOP"

| You got it!

  |======================================================================              |  84%
| Make sure to save your script before you type submit().

> telegram("yo","lo")
[1] "START yo lo STOP"
> submit()

| Sourcing your script...


| Keep up the great work!

  |========================================================================            |  86%
| Time to use your mad_libs function. Make sure to name the place, adjective, and noun
| arguments in order for your function to work.

> mad_libs(place="lansing", adjective="cunning", noun="toad")
[1] "News from lansing today where cunning students took to the streets in protest of the new toad being installed on campus."

| Great job!

  |==========================================================================          |  88%
| We're coming to the end of this lesson, but there's still one more idea you should be made
| aware of.

...

  |===========================================================================         |  90%
| You're familiar with adding, subtracting, multiplying, and dividing numbers in R. To do
| this you use the +, -, *, and / symbols. These symbols are called binary operators because
| they take two inputs, an input from the left and an input from the right.

...

  |=============================================================================       |  92%
| In R you can define your own binary operators. In the next script I'll show you how.

...

  |===============================================================================     |  94%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| You got it right!

  |=================================================================================   |  96%
| You made your own binary operator! Let's test it out. Paste together the strings: 'I',
| 'love', 'R!' using your new binary operator.

> 'I' %p% 
+ 
+ 
+ q
Error in paste(preamble, epilogue) : 
  cannot coerce type 'closure' to vector of type 'character'
> 'I' %p% 'love' %p% 'R!'
[1] "I love R!"

| Excellent job!

  |==================================================================================  |  98%
| We've come to the end of our lesson! Go out there and write some great functions!

SECTION 10
MISSED SOME BUT I HAVE UP TO 24%

$zone
[1] "integer"

$area
[1] "integer"

$population
[1] "integer"

$language
[1] "integer"

$religion
[1] "integer"

$bars
[1] "integer"

$stripes
[1] "integer"

$colours
[1] "integer"

$red
[1] "integer"

$green
[1] "integer"

$blue
[1] "integer"

$gold
[1] "integer"

$white
[1] "integer"

$black
[1] "integer"

$orange
[1] "integer"

$mainhue
[1] "factor"

$circles
[1] "integer"

$crosses
[1] "integer"

$saltires
[1] "integer"

$quarters
[1] "integer"

$sunstars
[1] "integer"

$crescent
[1] "integer"

$triangle
[1] "integer"

$icon
[1] "integer"

$animate
[1] "integer"

$text
[1] "integer"

$topleft
[1] "factor"

$botright
[1] "factor"


| You nailed it! Good job!

  |======================                                                              |  26%
| The 'l' in 'lapply' stands for 'list'. Type class(cls_list) to confirm that lapply()
| returned a list.

> class(cls_list)
[1] "list"

| Excellent work!

  |========================                                                            |  28%
| As expected, we got a list of length 30 -- one element for each variable/column. The output
| would be considerably more compact if we could represent it as a vector instead of a list.

...

  |=========================                                                           |  30%
| You may remember from a previous lesson that lists are most helpful for storing multiple
| classes of data. In this case, since every element of the list returned by lapply() is a
| character vector of length one (i.e. "integer" and "vector"), cls_list can be simplified to
| a character vector. To do this manually, type as.character(cls_list).

> as.character(cls_list)
 [1] "factor"  "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer"
[10] "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer" "factor" 
[19] "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer"
[28] "integer" "factor"  "factor" 

| Excellent job!

  |===========================                                                         |  32%
| sapply() allows you to automate this process by calling lapply() behind the scenes, but
| then attempting to simplify (hence the 's' in 'sapply') the result for you. Use sapply()
| the same way you used lapply() to get the class of each column of the flags dataset and
| store the result in cls_vect. If you need help, type ?sapply to bring up the documentation.

> sapply(flags, class)
      name   landmass       zone       area population   language   religion       bars 
  "factor"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer" 
   stripes    colours        red      green       blue       gold      white      black 
 "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer" 
    orange    mainhue    circles    crosses   saltires   quarters   sunstars   crescent 
 "integer"   "factor"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer" 
  triangle       icon    animate       text    topleft   botright 
 "integer"  "integer"  "integer"  "integer"   "factor"   "factor" 

| Keep trying! Or, type info() for more options.

| Type cls_vect <- sapply(flags, class) to store the column classes in a character vector
| called cls_vect.

> ?sapply
> cls_vect <- sapply(flags, class)

| All that practice is paying off!

  |=============================                                                       |  34%
| Use class(cls_vect) to confirm that sapply() simplified the result to a character vector.

> class(cls_vect)
[1] "character"

| That's the answer I was looking for.

  |==============================                                                      |  36%
| In general, if the result is a list where every element is of length one, then sapply()
| returns a vector. If the result is a list where every element is a vector of the same
| length (> 1), sapply() returns a matrix. If sapply() can't figure things out, then it just
| returns a list, no different from what lapply() would give you.

...

  |================================                                                    |  38%
| Let's practice using lapply() and sapply() some more!

...

  |==================================                                                  |  40%
| Columns 11 through 17 of our dataset are indicator variables, each representing a different
| color. The value of the indicator variable is 1 if the color is present in a country's flag
| and 0 otherwise.

...

  |===================================                                                 |  42%
| Therefore, if we want to know the total number of countries (in our dataset) with, for
| example, the color orange on their flag, we can just add up all of the 1s and 0s in the
| 'orange' column. Try sum(flags$orange) to see this.

> sum(flags$orange)
[1] 26

| That's a job well done!

  |=====================================                                               |  44%
| Now we want to repeat this operation for each of the colors recorded in the dataset.

...

  |=======================================                                             |  46%
| First, use flag_colors <- flags[, 11:17] to extract the columns containing the color data
| and store them in a new data frame called flag_colors. (Note the comma before 11:17. This
| subsetting command tells R that we want all rows, but only columns 11 through 17.)

> flag_colors <- flags[, 11:17]

| You're the best!

  |========================================                                            |  48%
| Use the head() function to look at the first 6 lines of flag_colors.

> head(flag_colors)
  red green blue gold white black orange
1   1     1    0    1     1     1      0
2   1     0    0    1     0     1      0
3   1     1    0    0     1     0      0
4   1     0    1    1     1     0      1
5   1     0    1    1     0     0      0
6   1     0    0    1     0     1      0

| Excellent work!

  |==========================================                                          |  50%
| To get a list containing the sum of each column of flag_colors, call the lapply() function
| with two arguments. The first argument is the object over which we are looping (i.e.
| flag_colors) and the second argument is the name of the function we wish to apply to each
| column (i.e. sum). Remember that the second argument is just the name of the function with
| no parentheses, etc.

> lapply(flag_colors, sum)
$red
[1] 153

$green
[1] 91

$blue
[1] 99

$gold
[1] 91

$white
[1] 146

$black
[1] 52

$orange
[1] 26


| Great job!

  |============================================                                        |  52%
| This tells us that of the 194 flags in our dataset, 153 contain the color red, 91 contain
| green, 99 contain blue, and so on.

...

  |=============================================                                       |  54%
| The result is a list, since lapply() always returns a list. Each element of this list is of
| length one, so the result can be simplified to a vector by calling sapply() instead of
| lapply(). Try it now.

> sapply(flag_colors, sum)
   red  green   blue   gold  white  black orange 
   153     91     99     91    146     52     26 

| You are amazing!

  |===============================================                                     |  56%
| Perhaps it's more informative to find the proportion of flags (out of 194) containing each
| color. Since each column is just a bunch of 1s and 0s, the arithmetic mean of each column
| will give us the proportion of 1s. (If it's not clear why, think of a simpler situation
| where you have three 1s and two 0s -- (1 + 1 + 1 + 0 + 0)/5 = 3/5 = 0.6).

...

  |=================================================                                   |  58%
| Use sapply() to apply the mean() function to each column of flag_colors. Remember that the
| second argument to sapply() should just specify the name of the function (i.e. mean) that
| you want to apply.

> sapply(flag_colors, mean)
      red     green      blue      gold     white     black    orange 
0.7886598 0.4690722 0.5103093 0.4690722 0.7525773 0.2680412 0.1340206 

| You nailed it! Good job!

  |==================================================                                  |  60%
| In the examples we've looked at so far, sapply() has been able to simplify the result to
| vector. That's because each element of the list returned by lapply() was a vector of length
| one. Recall that sapply() instead returns a matrix when each element of the list returned
| by lapply() is a vector of the same length (> 1).

...

  |====================================================                                |  62%
| To illustrate this, let's extract columns 19 through 23 from the flags dataset and store
| the result in a new data frame called flag_shapes. flag_shapes <- flags[, 19:23] will do
| it.

> flag_shapes <- flags[, 19:23]

| All that hard work is paying off!

  |======================================================                              |  64%
| Each of these columns (i.e. variables) represents the number of times a particular shape or
| design appears on a country's flag. We are interested in the minimum and maximum number of
| times each shape or design appears.

...

  |=======================================================                             |  66%
| The range() function returns the minimum and maximum of its first argument, which should be
| a numeric vector. Use lapply() to apply the range function to each column of flag_shapes.
| Don't worry about storing the result in a new variable. By now, we know that lapply()
| always returns a list.

> lapply(flag_shapes, range)
$circles
[1] 0 4

$crosses
[1] 0 2

$saltires
[1] 0 1

$quarters
[1] 0 4

$sunstars
[1]  0 50


| Excellent work!

  |=========================================================                           |  68%
| Do the same operation, but using sapply() and store the result in a variable called
| shape_mat.

> shape_mat <- sapply(flag_shapes, range)

| Keep working like that and you'll get there!

  |===========================================================                         |  70%
| View the contents of shape_mat.

> shape_mat
     circles crosses saltires quarters sunstars
[1,]       0       0        0        0        0
[2,]       4       2        1        4       50

| Perseverance, that's the answer.

  |============================================================                        |  72%
| Each column of shape_mat gives the minimum (row 1) and maximum (row 2) number of times its
| respective shape appears in different flags.

...

  |==============================================================                      |  74%
| Use the class() function to confirm that shape_mat is a matrix.

> class(shape_mat)
[1] "matrix"

| You are amazing!

  |================================================================                    |  76%
| As we've seen, sapply() always attempts to simplify the result given by lapply(). It has
| been successful in doing so for each of the examples we've looked at so far. Let's look at
| an example where sapply() can't figure out how to simplify the result and thus returns a
| list, no different from lapply().

...

  |==================================================================                  |  78%
| When given a vector, the unique() function returns a vector with all duplicate elements
| removed. In other words, unique() returns a vector of only the 'unique' elements. To see
| how it works, try unique(c(3, 4, 5, 5, 5, 6, 6)).

> unique(c(3,4,5,5,5,6,6))
[1] 3 4 5 6

| You got it!

  |===================================================================                 |  80%
| We want to know the unique values for each variable in the flags dataset. To accomplish
| this, use lapply() to apply the unique() function to each column in the flags dataset,
| storing the result in a variable called unique_vals.

> unique_vals <- lapply(flags, unique)

| Perseverance, that's the answer.

  |=====================================================================               |  82%
| Print the value of unique_vals to the console.

> unique_vale
Error: object 'unique_vale' not found
> unique_vals
$name
  [1] Afghanistan              Albania                  Algeria                 
  [4] American-Samoa           Andorra                  Angola                  
  [7] Anguilla                 Antigua-Barbuda          Argentina               
 [10] Argentine                Australia                Austria                 
 [13] Bahamas                  Bahrain                  Bangladesh              
 [16] Barbados                 Belgium                  Belize                  
 [19] Benin                    Bermuda                  Bhutan                  
 [22] Bolivia                  Botswana                 Brazil                  
 [25] British-Virgin-Isles     Brunei                   Bulgaria                
 [28] Burkina                  Burma                    Burundi                 
 [31] Cameroon                 Canada                   Cape-Verde-Islands      
 [34] Cayman-Islands           Central-African-Republic Chad                    
 [37] Chile                    China                    Colombia                
 [40] Comorro-Islands          Congo                    Cook-Islands            
 [43] Costa-Rica               Cuba                     Cyprus                  
 [46] Czechoslovakia           Denmark                  Djibouti                
 [49] Dominica                 Dominican-Republic       Ecuador                 
 [52] Egypt                    El-Salvador              Equatorial-Guinea       
 [55] Ethiopia                 Faeroes                  Falklands-Malvinas      
 [58] Fiji                     Finland                  France                  
 [61] French-Guiana            French-Polynesia         Gabon                   
 [64] Gambia                   Germany-DDR              Germany-FRG             
 [67] Ghana                    Gibraltar                Greece                  
 [70] Greenland                Grenada                  Guam                    
 [73] Guatemala                Guinea                   Guinea-Bissau           
 [76] Guyana                   Haiti                    Honduras                
 [79] Hong-Kong                Hungary                  Iceland                 
 [82] India                    Indonesia                Iran                    
 [85] Iraq                     Ireland                  Israel                  
 [88] Italy                    Ivory-Coast              Jamaica                 
 [91] Japan                    Jordan                   Kampuchea               
 [94] Kenya                    Kiribati                 Kuwait                  
 [97] Laos                     Lebanon                  Lesotho                 
[100] Liberia                  Libya                    Liechtenstein           
[103] Luxembourg               Malagasy                 Malawi                  
[106] Malaysia                 Maldive-Islands          Mali                    
[109] Malta                    Marianas                 Mauritania              
[112] Mauritius                Mexico                   Micronesia              
[115] Monaco                   Mongolia                 Montserrat              
[118] Morocco                  Mozambique               Nauru                   
[121] Nepal                    Netherlands              Netherlands-Antilles    
[124] New-Zealand              Nicaragua                Niger                   
[127] Nigeria                  Niue                     North-Korea             
[130] North-Yemen              Norway                   Oman                    
[133] Pakistan                 Panama                   Papua-New-Guinea        
[136] Parguay                  Peru                     Philippines             
[139] Poland                   Portugal                 Puerto-Rico             
[142] Qatar                    Romania                  Rwanda                  
[145] San-Marino               Sao-Tome                 Saudi-Arabia            
[148] Senegal                  Seychelles               Sierra-Leone            
[151] Singapore                Soloman-Islands          Somalia                 
[154] South-Africa             South-Korea              South-Yemen             
[157] Spain                    Sri-Lanka                St-Helena               
[160] St-Kitts-Nevis           St-Lucia                 St-Vincent              
[163] Sudan                    Surinam                  Swaziland               
[166] Sweden                   Switzerland              Syria                   
[169] Taiwan                   Tanzania                 Thailand                
[172] Togo                     Tonga                    Trinidad-Tobago         
[175] Tunisia                  Turkey                   Turks-Cocos-Islands     
[178] Tuvalu                   UAE                      Uganda                  
[181] UK                       Uruguay                  US-Virgin-Isles         
[184] USA                      USSR                     Vanuatu                 
[187] Vatican-City             Venezuela                Vietnam                 
[190] Western-Samoa            Yugoslavia               Zaire                   
[193] Zambia                   Zimbabwe                
194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola ... Zimbabwe

$landmass
[1] 5 3 4 6 1 2

$zone
[1] 1 3 2 4

$area
  [1]   648    29  2388     0  1247  2777  7690    84    19     1   143    31    23   113
 [15]    47  1099   600  8512     6   111   274   678    28   474  9976     4   623  1284
 [29]   757  9561  1139     2   342    51   115     9   128    43    22    49   284  1001
 [43]    21  1222    12    18   337   547    91   268    10   108   249   239   132  2176
 [57]   109   246    36   215   112    93   103  3268  1904  1648   435    70   301   323
 [71]    11   372    98   181   583   236    30  1760     3   587   118   333  1240  1031
 [85]  1973  1566   447   783   140    41  1267   925   121   195   324   212   804    76
 [99]   463   407  1285   300   313    92   237    26  2150   196    72   637  1221    99
[113]   288   505    66  2506    63    17   450   185   945   514    57     5   164   781
[127]   245   178  9363 22402    15   912   256   905   753   391

$population
 [1]   16    3   20    0    7   28   15    8   90   10    1    6  119    9   35    4   24    2
[19]   11 1008    5   47   31   54   17   61   14  684  157   39   57  118   13   77   12   56
[37]   18   84   48   36   22   29   38   49   45  231  274   60

$language
 [1] 10  6  8  1  2  4  3  5  7  9

$religion
[1] 2 6 1 0 5 3 4 7

$bars
[1] 0 2 3 1 5

$stripes
 [1]  3  0  2  1  5  9 11 14  4  6 13  7

$colours
[1] 5 3 2 8 6 4 7 1

$red
[1] 1 0

$green
[1] 1 0

$blue
[1] 0 1

$gold
[1] 1 0

$white
[1] 1 0

$black
[1] 1 0

$orange
[1] 0 1

$mainhue
[1] green  red    blue   gold   white  orange black  brown 
Levels: black blue brown gold green orange red white

$circles
[1] 0 1 4 2

$crosses
[1] 0 1 2

$saltires
[1] 0 1

$quarters
[1] 0 1 4

$sunstars
 [1]  1  0  6 22 14  3  4  5 15 10  7  2  9 50

$crescent
[1] 0 1

$triangle
[1] 0 1

$icon
[1] 1 0

$animate
[1] 0 1

$text
[1] 0 1

$topleft
[1] black  red    green  blue   white  orange gold  
Levels: black blue gold green orange red white

$botright
[1] green  red    white  black  blue   gold   orange brown 
Levels: black blue brown gold green orange red white


| You are quite good my friend!

  |=======================================================================             |  84%
| Since unique_vals is a list, you can use what you've learned to determine the length of
| each element of unique_vals (i.e. the number of unique values for each variable). Simplify
| the result, if possible. Hint: Apply the length() function to each element of unique_vals.

> lapply(unique_vals, length)
$name
[1] 194

$landmass
[1] 6

$zone
[1] 4

$area
[1] 136

$population
[1] 48

$language
[1] 10

$religion
[1] 8

$bars
[1] 5

$stripes
[1] 12

$colours
[1] 8

$red
[1] 2

$green
[1] 2

$blue
[1] 2

$gold
[1] 2

$white
[1] 2

$black
[1] 2

$orange
[1] 2

$mainhue
[1] 8

$circles
[1] 4

$crosses
[1] 3

$saltires
[1] 2

$quarters
[1] 3

$sunstars
[1] 14

$crescent
[1] 2

$triangle
[1] 2

$icon
[1] 2

$animate
[1] 2

$text
[1] 2

$topleft
[1] 7

$botright
[1] 8


| You almost had it, but not quite. Try again. Or, type info() for more options.

| Apply the length() function to each element of the unique_vals list using sapply().
| Remember, no parentheses after the name of the function you are applying (i.e. length).

> sapply(unique_vals, length)
      name   landmass       zone       area population   language   religion       bars 
       194          6          4        136         48         10          8          5 
   stripes    colours        red      green       blue       gold      white      black 
        12          8          2          2          2          2          2          2 
    orange    mainhue    circles    crosses   saltires   quarters   sunstars   crescent 
         2          8          4          3          2          3         14          2 
  triangle       icon    animate       text    topleft   botright 
         2          2          2          2          7          8 

| You are doing so well!

  |========================================================================            |  86%
| The fact that the elements of the unique_vals list are all vectors of *different* length
| poses a problem for sapply(), since there's no obvious way of simplifying the result.

...

  |==========================================================================          |  88%
| Use sapply() to apply the unique() function to each column of the flags dataset to see that
| you get the same unsimplified list that you got from lapply().

> sapply(flags, unique)
$name
  [1] Afghanistan              Albania                  Algeria                 
  [4] American-Samoa           Andorra                  Angola                  
  [7] Anguilla                 Antigua-Barbuda          Argentina               
 [10] Argentine                Australia                Austria                 
 [13] Bahamas                  Bahrain                  Bangladesh              
 [16] Barbados                 Belgium                  Belize                  
 [19] Benin                    Bermuda                  Bhutan                  
 [22] Bolivia                  Botswana                 Brazil                  
 [25] British-Virgin-Isles     Brunei                   Bulgaria                
 [28] Burkina                  Burma                    Burundi                 
 [31] Cameroon                 Canada                   Cape-Verde-Islands      
 [34] Cayman-Islands           Central-African-Republic Chad                    
 [37] Chile                    China                    Colombia                
 [40] Comorro-Islands          Congo                    Cook-Islands            
 [43] Costa-Rica               Cuba                     Cyprus                  
 [46] Czechoslovakia           Denmark                  Djibouti                
 [49] Dominica                 Dominican-Republic       Ecuador                 
 [52] Egypt                    El-Salvador              Equatorial-Guinea       
 [55] Ethiopia                 Faeroes                  Falklands-Malvinas      
 [58] Fiji                     Finland                  France                  
 [61] French-Guiana            French-Polynesia         Gabon                   
 [64] Gambia                   Germany-DDR              Germany-FRG             
 [67] Ghana                    Gibraltar                Greece                  
 [70] Greenland                Grenada                  Guam                    
 [73] Guatemala                Guinea                   Guinea-Bissau           
 [76] Guyana                   Haiti                    Honduras                
 [79] Hong-Kong                Hungary                  Iceland                 
 [82] India                    Indonesia                Iran                    
 [85] Iraq                     Ireland                  Israel                  
 [88] Italy                    Ivory-Coast              Jamaica                 
 [91] Japan                    Jordan                   Kampuchea               
 [94] Kenya                    Kiribati                 Kuwait                  
 [97] Laos                     Lebanon                  Lesotho                 
[100] Liberia                  Libya                    Liechtenstein           
[103] Luxembourg               Malagasy                 Malawi                  
[106] Malaysia                 Maldive-Islands          Mali                    
[109] Malta                    Marianas                 Mauritania              
[112] Mauritius                Mexico                   Micronesia              
[115] Monaco                   Mongolia                 Montserrat              
[118] Morocco                  Mozambique               Nauru                   
[121] Nepal                    Netherlands              Netherlands-Antilles    
[124] New-Zealand              Nicaragua                Niger                   
[127] Nigeria                  Niue                     North-Korea             
[130] North-Yemen              Norway                   Oman                    
[133] Pakistan                 Panama                   Papua-New-Guinea        
[136] Parguay                  Peru                     Philippines             
[139] Poland                   Portugal                 Puerto-Rico             
[142] Qatar                    Romania                  Rwanda                  
[145] San-Marino               Sao-Tome                 Saudi-Arabia            
[148] Senegal                  Seychelles               Sierra-Leone            
[151] Singapore                Soloman-Islands          Somalia                 
[154] South-Africa             South-Korea              South-Yemen             
[157] Spain                    Sri-Lanka                St-Helena               
[160] St-Kitts-Nevis           St-Lucia                 St-Vincent              
[163] Sudan                    Surinam                  Swaziland               
[166] Sweden                   Switzerland              Syria                   
[169] Taiwan                   Tanzania                 Thailand                
[172] Togo                     Tonga                    Trinidad-Tobago         
[175] Tunisia                  Turkey                   Turks-Cocos-Islands     
[178] Tuvalu                   UAE                      Uganda                  
[181] UK                       Uruguay                  US-Virgin-Isles         
[184] USA                      USSR                     Vanuatu                 
[187] Vatican-City             Venezuela                Vietnam                 
[190] Western-Samoa            Yugoslavia               Zaire                   
[193] Zambia                   Zimbabwe                
194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola ... Zimbabwe

$landmass
[1] 5 3 4 6 1 2

$zone
[1] 1 3 2 4

$area
  [1]   648    29  2388     0  1247  2777  7690    84    19     1   143    31    23   113
 [15]    47  1099   600  8512     6   111   274   678    28   474  9976     4   623  1284
 [29]   757  9561  1139     2   342    51   115     9   128    43    22    49   284  1001
 [43]    21  1222    12    18   337   547    91   268    10   108   249   239   132  2176
 [57]   109   246    36   215   112    93   103  3268  1904  1648   435    70   301   323
 [71]    11   372    98   181   583   236    30  1760     3   587   118   333  1240  1031
 [85]  1973  1566   447   783   140    41  1267   925   121   195   324   212   804    76
 [99]   463   407  1285   300   313    92   237    26  2150   196    72   637  1221    99
[113]   288   505    66  2506    63    17   450   185   945   514    57     5   164   781
[127]   245   178  9363 22402    15   912   256   905   753   391

$population
 [1]   16    3   20    0    7   28   15    8   90   10    1    6  119    9   35    4   24    2
[19]   11 1008    5   47   31   54   17   61   14  684  157   39   57  118   13   77   12   56
[37]   18   84   48   36   22   29   38   49   45  231  274   60

$language
 [1] 10  6  8  1  2  4  3  5  7  9

$religion
[1] 2 6 1 0 5 3 4 7

$bars
[1] 0 2 3 1 5

$stripes
 [1]  3  0  2  1  5  9 11 14  4  6 13  7

$colours
[1] 5 3 2 8 6 4 7 1

$red
[1] 1 0

$green
[1] 1 0

$blue
[1] 0 1

$gold
[1] 1 0

$white
[1] 1 0

$black
[1] 1 0

$orange
[1] 0 1

$mainhue
[1] green  red    blue   gold   white  orange black  brown 
Levels: black blue brown gold green orange red white

$circles
[1] 0 1 4 2

$crosses
[1] 0 1 2

$saltires
[1] 0 1

$quarters
[1] 0 1 4

$sunstars
 [1]  1  0  6 22 14  3  4  5 15 10  7  2  9 50

$crescent
[1] 0 1

$triangle
[1] 0 1

$icon
[1] 1 0

$animate
[1] 0 1

$text
[1] 0 1

$topleft
[1] black  red    green  blue   white  orange gold  
Levels: black blue gold green orange red white

$botright
[1] green  red    white  black  blue   gold   orange brown 
Levels: black blue brown gold green orange red white


| Keep up the great work!

  |============================================================================        |  90%
| Occasionally, you may need to apply a function that is not yet defined, thus requiring you
| to write your own. Writing functions in R is beyond the scope of this lesson, but let's
| look at a quick example of how you might do so in the context of loop functions.

...

  |=============================================================================       |  92%
| Pretend you are interested in only the second item from each element of the unique_vals
| list that you just created. Since each element of the unique_vals list is a vector and
| we're not aware of any built-in function in R that returns the second element of a vector,
| we will construct our own function.

...

  |===============================================================================     |  94%
| lapply(unique_vals, function(elem) elem[2]) will return a list containing the second item
| from each element of the unique_vals list. Note that our function takes one argument, elem,
| which is just a 'dummy variable' that takes on the value of each element of unique_vals, in
| turn.

> lapply(unique_vals, function(elem) elem[2])
$name
[1] Albania
194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola ... Zimbabwe

$landmass
[1] 3

$zone
[1] 3

$area
[1] 29

$population
[1] 3

$language
[1] 6

$religion
[1] 6

$bars
[1] 2

$stripes
[1] 0

$colours
[1] 3

$red
[1] 0

$green
[1] 0

$blue
[1] 1

$gold
[1] 0

$white
[1] 0

$black
[1] 0

$orange
[1] 1

$mainhue
[1] red
Levels: black blue brown gold green orange red white

$circles
[1] 1

$crosses
[1] 1

$saltires
[1] 1

$quarters
[1] 1

$sunstars
[1] 0

$crescent
[1] 1

$triangle
[1] 1

$icon
[1] 0

$animate
[1] 1

$text
[1] 1

$topleft
[1] red
Levels: black blue gold green orange red white

$botright
[1] red
Levels: black blue brown gold green orange red white


| Great job!

  |=================================================================================   |  96%
| The only difference between previous examples and this one is that we are defining and
| using our own function right in the call to lapply(). Our function has no name and
| disappears as soon as lapply() is done using it. So-called 'anonymous functions' can be
| very useful when one of R's built-in functions isn't an option.

...

  |==================================================================================  |  98%
| In this lesson, you learned how to use the powerful lapply() and sapply() functions to
| apply an operation over the elements of a list. In the next lesson, we'll take a look at
| some close relatives of lapply() and sapply().

...

  |====================================================================================| 100%

  SECTION 11


Selection: 11

  |                                                                                                     |   0%

| In the last lesson, you learned about the two most fundamental members of R's *apply family of functions:
| lapply() and sapply(). Both take a list as input, apply a function to each element of the list, then combine
| and return the result. lapply() always returns a list, whereas sapply() attempts to simplify the result.

... 

  |====                                                                                                 |   4%
| In this lesson, you'll learn how to use vapply() and tapply(), each of which serves a very specific purpose
| within the Split-Apply-Combine methodology. For consistency, we'll use the same dataset we used in the
| 'lapply and sapply' lesson.

...

  |========                                                                                             |   8%
| The Flags dataset from the UCI Machine Learning Repository contains details of various nations and their
| flags. More information may be found here: http://archive.ics.uci.edu/ml/datasets/Flags

...

  |============                                                                                         |  12%
| I've stored the data in a variable called flags. If it's been a while since you completed the 'lapply and
| sapply' lesson, you may want to reacquaint yourself with the data by using functions like dim(), head(),
| str(), and summary() when you return to the prompt (>). You can also type viewinfo() at the prompt to bring
| up some documentation for the dataset. Let's get started!

...

  |================                                                                                     |  16%
| As you saw in the last lesson, the unique() function returns a vector of the unique values contained in the
| object passed to it. Therefore, sapply(flags, unique) returns a list containing one vector of unique values
| for each column of the flags dataset. Try it again now.

> sapply(flags,unique)
$name
  [1] Afghanistan              Albania                  Algeria                  American-Samoa          
  [5] Andorra                  Angola                   Anguilla                 Antigua-Barbuda         
  [9] Argentina                Argentine                Australia                Austria                 
 [13] Bahamas                  Bahrain                  Bangladesh               Barbados                
 [17] Belgium                  Belize                   Benin                    Bermuda                 
 [21] Bhutan                   Bolivia                  Botswana                 Brazil                  
 [25] British-Virgin-Isles     Brunei                   Bulgaria                 Burkina                 
 [29] Burma                    Burundi                  Cameroon                 Canada                  
 [33] Cape-Verde-Islands       Cayman-Islands           Central-African-Republic Chad                    
 [37] Chile                    China                    Colombia                 Comorro-Islands         
 [41] Congo                    Cook-Islands             Costa-Rica               Cuba                    
 [45] Cyprus                   Czechoslovakia           Denmark                  Djibouti                
 [49] Dominica                 Dominican-Republic       Ecuador                  Egypt                   
 [53] El-Salvador              Equatorial-Guinea        Ethiopia                 Faeroes                 
 [57] Falklands-Malvinas       Fiji                     Finland                  France                  
 [61] French-Guiana            French-Polynesia         Gabon                    Gambia                  
 [65] Germany-DDR              Germany-FRG              Ghana                    Gibraltar               
 [69] Greece                   Greenland                Grenada                  Guam                    
 [73] Guatemala                Guinea                   Guinea-Bissau            Guyana                  
 [77] Haiti                    Honduras                 Hong-Kong                Hungary                 
 [81] Iceland                  India                    Indonesia                Iran                    
 [85] Iraq                     Ireland                  Israel                   Italy                   
 [89] Ivory-Coast              Jamaica                  Japan                    Jordan                  
 [93] Kampuchea                Kenya                    Kiribati                 Kuwait                  
 [97] Laos                     Lebanon                  Lesotho                  Liberia                 
[101] Libya                    Liechtenstein            Luxembourg               Malagasy                
[105] Malawi                   Malaysia                 Maldive-Islands          Mali                    
[109] Malta                    Marianas                 Mauritania               Mauritius               
[113] Mexico                   Micronesia               Monaco                   Mongolia                
[117] Montserrat               Morocco                  Mozambique               Nauru                   
[121] Nepal                    Netherlands              Netherlands-Antilles     New-Zealand             
[125] Nicaragua                Niger                    Nigeria                  Niue                    
[129] North-Korea              North-Yemen              Norway                   Oman                    
[133] Pakistan                 Panama                   Papua-New-Guinea         Parguay                 
[137] Peru                     Philippines              Poland                   Portugal                
[141] Puerto-Rico              Qatar                    Romania                  Rwanda                  
[145] San-Marino               Sao-Tome                 Saudi-Arabia             Senegal                 
[149] Seychelles               Sierra-Leone             Singapore                Soloman-Islands         
[153] Somalia                  South-Africa             South-Korea              South-Yemen             
[157] Spain                    Sri-Lanka                St-Helena                St-Kitts-Nevis          
[161] St-Lucia                 St-Vincent               Sudan                    Surinam                 
[165] Swaziland                Sweden                   Switzerland              Syria                   
[169] Taiwan                   Tanzania                 Thailand                 Togo                    
[173] Tonga                    Trinidad-Tobago          Tunisia                  Turkey                  
[177] Turks-Cocos-Islands      Tuvalu                   UAE                      Uganda                  
[181] UK                       Uruguay                  US-Virgin-Isles          USA                     
[185] USSR                     Vanuatu                  Vatican-City             Venezuela               
[189] Vietnam                  Western-Samoa            Yugoslavia               Zaire                   
[193] Zambia                   Zimbabwe                
194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola Anguilla Antigua-Barbuda ... Zimbabwe

$landmass
[1] 5 3 4 6 1 2

$zone
[1] 1 3 2 4

$area
  [1]   648    29  2388     0  1247  2777  7690    84    19     1   143    31    23   113    47  1099   600
 [18]  8512     6   111   274   678    28   474  9976     4   623  1284   757  9561  1139     2   342    51
 [35]   115     9   128    43    22    49   284  1001    21  1222    12    18   337   547    91   268    10
 [52]   108   249   239   132  2176   109   246    36   215   112    93   103  3268  1904  1648   435    70
 [69]   301   323    11   372    98   181   583   236    30  1760     3   587   118   333  1240  1031  1973
 [86]  1566   447   783   140    41  1267   925   121   195   324   212   804    76   463   407  1285   300
[103]   313    92   237    26  2150   196    72   637  1221    99   288   505    66  2506    63    17   450
[120]   185   945   514    57     5   164   781   245   178  9363 22402    15   912   256   905   753   391

$population
 [1]   16    3   20    0    7   28   15    8   90   10    1    6  119    9   35    4   24    2   11 1008    5
[22]   47   31   54   17   61   14  684  157   39   57  118   13   77   12   56   18   84   48   36   22   29
[43]   38   49   45  231  274   60

$language
 [1] 10  6  8  1  2  4  3  5  7  9

$religion
[1] 2 6 1 0 5 3 4 7

$bars
[1] 0 2 3 1 5

$stripes
 [1]  3  0  2  1  5  9 11 14  4  6 13  7

$colours
[1] 5 3 2 8 6 4 7 1

$red
[1] 1 0

$green
[1] 1 0

$blue
[1] 0 1

$gold
[1] 1 0

$white
[1] 1 0

$black
[1] 1 0

$orange
[1] 0 1

$mainhue
[1] green  red    blue   gold   white  orange black  brown 
Levels: black blue brown gold green orange red white

$circles
[1] 0 1 4 2

$crosses
[1] 0 1 2

$saltires
[1] 0 1

$quarters
[1] 0 1 4

$sunstars
 [1]  1  0  6 22 14  3  4  5 15 10  7  2  9 50

$crescent
[1] 0 1

$triangle
[1] 0 1

$icon
[1] 1 0

$animate
[1] 0 1

$text
[1] 0 1

$topleft
[1] black  red    green  blue   white  orange gold  
Levels: black blue gold green orange red white

$botright
[1] green  red    white  black  blue   gold   orange brown 
Levels: black blue brown gold green orange red white


| You're the best!

  |====================                                                                                 |  20%
| What if you had forgotten how unique() works and mistakenly thought it returns the *number* of unique values
| contained in the object passed to it? Then you might have incorrectly expected sapply(flags, unique) to
| return a numeric vector, since each element of the list returned would contain a single number and sapply()
| could then simplify the result to a vector.

...

  |========================                                                                             |  24%
| When working interactively (at the prompt), this is not much of a problem, since you see the result
| immediately and will quickly recognize your mistake. However, when working non-interactively (e.g. writing
| your own functions), a misunderstanding may go undetected and cause incorrect results later on. Therefore,
| you may wish to be more careful and that's where vapply() is useful.

...

  |============================                                                                         |  28%
| Whereas sapply() tries to 'guess' the correct format of the result, vapply() allows you to specify it
| explicitly. If the result doesn't match the format you specify, vapply() will throw an error, causing the
| operation to stop. This can prevent significant problems in your code that might be caused by getting
| unexpected return values from sapply().

...

  |================================                                                                     |  32%
| Try vapply(flags, unique, numeric(1)), which says that you expect each element of the result to be a numeric
| vector of length 1. Since this is NOT actually the case, YOU WILL GET AN ERROR. Once you get the error, type
| ok() to continue to the next question.

> vapply(flags, unique, numeric(1))
Error in vapply(flags, unique, numeric(1)) : values must be length 1,
 but FUN(X[[1]]) result is length 194
> ok()

| Keep working like that and you'll get there!

  |====================================                                                                 |  36%
| Recall from the previous lesson that sapply(flags, class) will return a character vector containing the
| class of each column in the dataset. Try that again now to see the result.

> sapply(flags, class)
      name   landmass       zone       area population   language   religion       bars    stripes    colours 
  "factor"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer" 
       red      green       blue       gold      white      black     orange    mainhue    circles    crosses 
 "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"   "factor"  "integer"  "integer" 
  saltires   quarters   sunstars   crescent   triangle       icon    animate       text    topleft   botright 
 "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"   "factor"   "factor" 

| You are doing so well!

  |========================================                                                             |  40%
| If we wish to be explicit about the format of the result we expect, we can use vapply(flags, class,
| character(1)). The 'character(1)' argument tells R that we expect the class function to return a character
| vector of length 1 when applied to EACH column of the flags dataset. Try it now.

> vapply(flags, class, character(1))
      name   landmass       zone       area population   language   religion       bars    stripes    colours 
  "factor"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer" 
       red      green       blue       gold      white      black     orange    mainhue    circles    crosses 
 "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"   "factor"  "integer"  "integer" 
  saltires   quarters   sunstars   crescent   triangle       icon    animate       text    topleft   botright 
 "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"   "factor"   "factor" 

| Excellent job!

  |============================================                                                         |  44%
| Note that since our expectation was correct (i.e. character(1)), the vapply() result is identical to the
| sapply() result -- a character vector of column classes.

...

  |================================================                                                     |  48%
| You might think of vapply() as being 'safer' than sapply(), since it requires you to specify the format of
| the output in advance, instead of just allowing R to 'guess' what you wanted. In addition, vapply() may
| perform faster than sapply() for large datasets. However, when doing data analysis interactively (at the
| prompt), sapply() saves you some typing and will often be good enough.

...

  |=====================================================                                                |  52%
| As a data analyst, you'll often wish to split your data up into groups based on the value of some variable,
| then apply a function to the members of each group. The next function we'll look at, tapply(), does exactly
| that.

...

  |=========================================================                                            |  56%
| Use ?tapply to pull up the documentation.

> ?tapply

| You're the best!

  |=============================================================                                        |  60%
| The 'landmass' variable in our dataset takes on integer values between 1 and 6, each of which represents a
| different part of the world. Use table(flags$landmass) to see how many flags/countries fall into each group.

> table(flags$landmass)

 1  2  3  4  5  6 
31 17 35 52 39 20 

| You are amazing!

  |=================================================================                                    |  64%
| The 'animate' variable in our dataset takes the value 1 if a country's flag contains an animate image (e.g.
| an eagle, a tree, a human hand) and 0 otherwise. Use table(flags$animate) to see how many flags contain an
| animate image.

> table(flags$animate)

  0   1 
155  39 

| That's the answer I was looking for.

  |=====================================================================                                |  68%
| This tells us that 39 flags contain an animate object (animate = 1) and 155 do not (animate = 0).

...

  |=========================================================================                            |  72%
| If you take the arithmetic mean of a bunch of 0s and 1s, you get the proportion of 1s. Use
| tapply(flags$animate, flags$landmass, mean) to apply the mean function to the 'animate' variable separately
| for each of the six landmass groups, thus giving us the proportion of flags containing an animate image
| WITHIN each landmass group.

> tapply(flags$animate, flags$landmass, mean)
        1         2         3         4         5         6 
0.4193548 0.1764706 0.1142857 0.1346154 0.1538462 0.3000000 

| You are amazing!

  |=============================================================================                        |  76%
| The first landmass group (landmass = 1) corresponds to North America and contains the highest proportion of
| flags with an animate image (0.4194).

...

  |=================================================================================                    |  80%
| Similarly, we can look at a summary of population values (in round millions) for countries with and without
| the color red on their flag with tapply(flags$population, flags$red, summary).

> tapply(flags$population, flags$red, summary)
$`0`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    3.00   27.63    9.00  684.00 

$`1`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    0.0     0.0     4.0    22.1    15.0  1008.0 


| Great job!

  |=====================================================================================                |  84%
| What is the median population (in millions) for countries *without* the color red on their flag?

1: 0.0
2: 27.6
3: 22.1
4: 3.0
5: 4.0
6: 9.0

Selection: 2

| You almost had it, but not quite. Try again.

| Use your result from the last question. Recall that red = 0 means that the color red is NOT present on a
| countries flag.

1: 0.0
2: 9.0
3: 22.1
4: 3.0
5: 27.6
6: 4.0

Selection: 4

| You got it right!

  |=========================================================================================            |  88%
| Lastly, use the same approach to look at a summary of population values for each of the six landmasses.

> tapply(flags$landmass, flags$population, summary)
$`0`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   1.000   3.000   3.321   5.250   6.000 

$`1`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    2.0     4.0     4.0     4.0     4.5     6.0 

$`2`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   3.500   4.000   3.833   5.000   6.000 

$`3`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   2.000   4.000   3.462   5.000   6.000 

$`4`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    1.0     3.0     4.0     3.4     4.0     5.0 

$`5`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   3.000   4.000   3.429   4.000   5.000 

$`6`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   2.000   4.000   3.111   4.000   5.000 

$`7`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      4       4       4       4       4       4 

$`8`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   2.250   3.000   2.833   3.750   4.000 

$`9`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   3.00    3.75    4.50    4.25    5.00    5.00 

$`10`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      1       3       3       3       3       5 

$`11`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   2.00    2.25    2.50    2.50    2.75    3.00 

$`12`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      4       4       4       4       4       4 

$`13`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   4.00    4.25    4.50    4.50    4.75    5.00 

$`14`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   2.00    2.75    3.50    3.50    4.25    5.00 

$`15`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   2.00    2.75    4.00    4.00    5.25    6.00 

$`16`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`17`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   3.00    3.25    3.50    3.50    3.75    4.00 

$`18`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  4.000   4.500   5.000   4.667   5.000   5.000 

$`20`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      4       4       4       4       4       4 

$`22`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      3       3       3       3       3       3 

$`24`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      1       1       1       1       1       1 

$`28`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    2.0     2.0     2.0     2.5     2.5     4.0 

$`29`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      4       4       4       4       4       4 

$`31`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      4       4       4       4       4       4 

$`35`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`36`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      3       3       3       3       3       3 

$`38`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      3       3       3       3       3       3 

$`39`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`45`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`47`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      4       4       4       4       4       4 

$`48`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      6       6       6       6       6       6 

$`49`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`54`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      3       3       3       3       3       3 

$`56`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   3.00    3.25    3.50    3.50    3.75    4.00 

$`57`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      3       3       3       3       3       3 

$`60`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`61`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      3       3       3       3       3       3 

$`77`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      1       1       1       1       1       1 

$`84`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`90`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`118`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`119`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      2       2       2       2       2       2 

$`157`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      6       6       6       6       6       6 

$`231`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      1       1       1       1       1       1 

$`274`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`684`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 

$`1008`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      5       5       5       5       5       5 


| Almost! Try again. Or, type info() for more options.

| You can see a summary of populations for each of the six landmasses by calling tapply() with three
| arguments: flags$population, flags$landmass, and summary.

> tapply(flags$population, flags$landmass, summary)
$`1`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    0.00   12.29    4.50  231.00 

$`2`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    1.00    6.00   15.71   15.00  119.00 

$`3`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    8.00   13.86   16.00   61.00 

$`4`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  0.000   1.000   5.000   8.788   9.750  56.000 

$`5`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    2.00   10.00   69.18   39.00 1008.00 

$`6`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    0.00   11.30    1.25  157.00 


| All that hard work is paying off!

  |=============================================================================================        |  92%
| What is the maximum population (in millions) for the fourth landmass group (Africa)?

1: 1010.0
2: 157.00
3: 56.00
4: 5.00
5: 119.0

Selection: 3

| Great job!

  |=================================================================================================    |  96%
| In this lesson, you learned how to use vapply() as a safer alternative to sapply(), which is most helpful
| when writing your own functions. You also learned how to use tapply() to split your data into groups based
| on the value of some variable, then apply a function to each group. These functions will come in handy on
| your quest to become a better data analyst.

...

  |=====================================================================================================| 100%